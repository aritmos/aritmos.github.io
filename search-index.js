var searchIndex = JSON.parse('{\
"sudoxu":{"doc":"Sudoxu","t":"AAADLLLLLLLLLLLIIIIKKKKKAAAAAAAAAAAAAANEDNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNDELLLLLLLLLLLLLLLLLLLLLLLLLLGDGIGILLLLLLLLALLLLLLLLLLLLGGGLLDENNLLLLLLLLLLLLLLLLLLLLLLLNNNDDELLLLLLMLLLLLLLLLLLLLMMLLLMLLLLLLLLLLLLLARR","n":["board","solver","solvers","Board","borrow","borrow_mut","fmt","fmt","from","into","to_string","try_from","try_from","try_into","type_id","LoggingSolver","Solver","StepLoggingSolver","StepSolver","init","solve","solve_with_logs","step","step","btr","psr","utils","core","filters","finders","structs","single_candidate","unique_candidate","cell","grid","idx","num","section","BannedBits","CandidateError","Cell","KnownMultipleNum","KnownNoNum","MultipleUniqueCandidates","NoCandidates","borrow","borrow","borrow_mut","borrow_mut","check","clone","clone","clone_into","clone_into","default","eq","eq","equivalent","fmt","fmt","fmt","from","from","into","into","is_known","new","new_known","new_unchecked","remove_candidates","set_candidates","set_known_bit","single_candidate","to_owned","to_owned","to_string","to_u16","try_from","try_from","try_into","try_into","type_id","type_id","zerod","FromStringError","Grid","GridError","borrow","borrow","borrow_mut","borrow_mut","default","eq","equivalent","fmt","fmt","from","from","from","get","get_mut","into","into","known_cell_update_neighbours","section","sections","try_from","try_from","try_into","try_into","type_id","type_id","unique_candidate","GridIdx","Idx","InnerIdx","IntoIdx","SectionIdx","TryIntoIdx","borrow","borrow_mut","clone","clone_into","eq","fmt","fmt","from","idxs","inner_idxs","into","new","new_unchecked","section_idxs","to_idx","to_owned","to_string","try_from","try_into","try_to_idx","type_id","GridIdx","InnerIdx","SectionIdx","inner_idxs","section_idxs","Num","NumErr","TooBig","Zero","borrow","borrow","borrow_mut","borrow_mut","clone","clone_into","eq","equivalent","fmt","fmt","from","from","into","into","new","new_unchecked","to_owned","try_from","try_from","try_into","try_into","type_id","type_id","Box","Column","Row","Section","SectionInfo","SectionKind","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","cells","clone","clone","clone_into","clone_into","eq","eq","fmt","fmt","fmt","from","from","from","grid_idxs","idx","info","into","into","into","kind","new","to_owned","to_owned","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","unique_candidate","boards","SUDOKU_1_UNSOLVED_FMT_STR","SUDOKU_1_UNSOLVED_STR"],"q":[[0,"sudoxu"],[3,"sudoxu::board"],[15,"sudoxu::solver"],[24,"sudoxu::solvers"],[27,"sudoxu::solvers::psr"],[28,"sudoxu::solvers::psr::core"],[31,"sudoxu::solvers::psr::core::finders"],[33,"sudoxu::solvers::psr::core::structs"],[38,"sudoxu::solvers::psr::core::structs::cell"],[84,"sudoxu::solvers::psr::core::structs::grid"],[113,"sudoxu::solvers::psr::core::structs::idx"],[140,"sudoxu::solvers::psr::core::structs::idx::idxs"],[145,"sudoxu::solvers::psr::core::structs::num"],[172,"sudoxu::solvers::psr::core::structs::section"],[217,"sudoxu::solvers::utils"],[218,"sudoxu::solvers::utils::boards"],[220,"core::fmt"],[221,"core::fmt"],[222,"core::result"],[223,"core::any"],[224,"core::option"],[225,"core::convert"]],"d":["I/O representation of sudoku boards.","The root <code>Solver</code> trait, implemented for all types which can …","Sudoku solver categories and utilities.","I/O version of the sudoku board. Each byte is guaranteed …","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","Parses a <code>String</code> into a Board. The parsing ignores any <code>char</code>…","","","A solver which logs its solution to the sudoku.","A sudoku solver.","A solver that steps through its process of solving the …","A sudoku solver that shows its steps into solving the …","Initialize <code>self</code> from a Board.","Compute the solution and return the solved board.","Solves the board while producing logs of each step.","Computes the following step towards solving the sudoku. …","Solves the board one step a time.","Backtracking (BTR) Solvers","Phase Space Reduction (PSR) Solvers","Utilities common to all solver categories, such as testing.","Core functionality for PSR solvers.","Functions that remove candidates from Cells and …","Functions that identify known values within Cells.","Types and implementations for the PSR solver category.","Single candidate detection.","Unique candidate detection.","The cells in a sudoku grid.","The sudoku board.","Safe indexing into comptime known arrays.","Representation of a known number within a Cell: <code>1 &lt;= N &lt;= 9</code>…","A row, column, or box within the grid.","Bits set within the banned sector.","Errors relating to a Cell’s candidates.","A cell within the grid. Holds information about what …","Known bit is set but multiple candidates are also set.","Known bit is set but no candidates are set.","Cell has multiple unique candidates within its Sections. …","Cell contains no candidates/value.","","","","","Checks if a given <code>Cell</code> has an allowed representation.","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Returns whether the known bit is set.","Creates a new <code>Cell</code> from an inner <code>u16</code>. Returns a …","Creates a Cell with a known value from a Num.","Creates a new <code>Cell</code>, which can either contain multiple …","Removes the candidate bits set in the mask from the cell.","Adds the set candidate bits in the <code>CellMask</code> to the <code>Cell</code>.","Sets the known bit of the given cell.","Checks if a <code>Cell</code> is not known and only contains a single …","","","","Returns the inner <code>u16</code> within the Cell.","","","","","","","Wrapper for <code>Cell::new_unchecked(0)</code>","Error in parsing a <code>String</code> into a <code>Grid</code>.","The sudoku Grid.","Grid-related errors","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Get a copy of the <code>Cell</code> the given index.","Get a mutable reference to the <code>Cell</code> at the given index.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Update the neighbours (all remaining <code>Cell</code>s in each <code>Section</code>…","Returns (a copy of) the specified <code>Section</code>.","Returns (copies of) the <code>Section</code>s of the <code>Cell</code> at the given …","","","","","","","Checks if a <code>Cell</code> contains a unique candidate within its …","An index into the cells of a grid:","A generic indexing type used to safely access comptime …","An index into a <code>Section</code>’s Cells. For rows(columns) these …","Unsafe uint -&gt; Idx conversion.","An index into the sections of a grid. For rows and …","Safe uint -&gt; Idx conversion.","","","","","","","","Returns the argument unchanged.","Concrete <code>Idx</code>s.","Returns the <code>InnerIdx</code>s associated to the given <code>GridIdx</code>, …","Calls <code>U::from(self)</code>.","Tries to create an <code>Idx&lt;N&gt;</code> from a <code>uint</code>. Returns None if the …","Create an <code>Idx&lt;N&gt;</code> from a <code>usize</code>.","Returns the <code>SectionIdx</code>s associated to the given <code>GridIdx</code>, …","Casts a uint into an <code>Idx&lt;N&gt;</code>, without performing the bounds …","","","","","Tries to cast a uint into an <code>Idx&lt;N&gt;</code>. Returns <code>None</code> if <code>self</code> …","","An index into the cells of a grid:","An index into a <code>Section</code>’s Cells. For rows(columns) these …","An index into the sections of a grid. For rows and …","Returns the <code>InnerIdx</code>s associated to the given <code>GridIdx</code>, …","Returns the <code>SectionIdx</code>s associated to the given <code>GridIdx</code>, …","A known number within a <code>Cell</code>, satisfying <code>1 &lt;= N &lt;= 9</code>.","<code>Num</code>-related errors.","<code>n &gt; 9</code>","<code>n == 0</code>","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Creates a <code>Num</code> from a <code>u8</code>. Returns an error if <code>n</code> is not in …","Creates a <code>Num</code> from a <code>u8</code>. Does not apply the bounds check.","","","","","","","","Box: 3x3 square within the grid.","Column: Vertical line within the grid.","Row: Horizontal line within the grid.","A row, column, or box of <code>Cell</code>s.","Information to identify a Section within the grid.","An enum for representing the kinds of <code>Section</code>s.","","","","","","","The underlying array of <code>Cell</code>s.","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Return the grid indexes of the provided section.","What (section) index is it.","The information linking to what <code>Section</code> within the <code>Grid</code> …","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","What kind of <code>Section</code> is it.","Create a new <code>SectionInfo</code>.","","","","","","","","","","","","Finds if the <code>Cell</code> at <code>inner_idx</code> contains a candidate found …","I/O Boards to test solvers and formatting.","Board 01 unsolved as <code>board.to_string()</code>.","Board 01 unsolved as input <code>&amp;str</code>."],"i":[0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,27,27,28,29,30,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0,9,9,9,9,8,9,8,9,8,8,9,8,9,8,8,9,8,8,8,9,8,9,8,9,8,8,8,8,8,8,8,8,8,9,8,8,8,9,8,9,8,9,8,14,0,0,13,14,13,14,13,13,13,13,14,13,13,14,13,13,13,14,13,13,13,13,14,13,14,13,14,13,0,0,0,0,0,0,19,19,19,19,19,19,19,19,0,19,19,19,19,19,31,19,19,19,19,32,19,0,0,0,15,15,0,0,24,24,12,24,12,24,12,12,12,12,12,24,12,24,12,24,12,12,12,12,24,12,24,12,24,26,26,26,0,0,0,17,16,26,17,16,26,17,16,26,16,26,16,26,17,16,26,17,16,26,16,16,17,17,16,26,16,16,16,26,17,16,26,17,16,26,17,16,26,17,0,0,0],"f":[0,0,0,0,[[]],[[]],[[1,2],3],[[1,2],3],[[]],[[]],[[],4],[[],5],[4,[[5,[1]]]],[[],5],[[],6],0,0,0,0,[1],[[],1],[[]],[[],[[7,[1]]]],[[],7],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[[]],[[]],[[]],[[]],[8,[[5,[9]]]],[8,8],[9,9],[[]],[[]],[[],8],[[8,8],10],[[9,9],10],[[],10],[[8,2],3],[[8,2],3],[[9,2],3],[[]],[[]],[[]],[[]],[8,10],[11,[[5,[8,9]]]],[12,8],[11,8],0,0,[8],[8,[[7,[12]]]],[[]],[[]],[[],4],[8,11],[[],5],[[],5],[[],5],[[],5],[[],6],[[],6],[[],8],0,0,0,[[]],[[]],[[]],[[]],[[],13],[[13,13],10],[[],10],[[13,2],3],[[14,2],3],[1,13],[[]],[[]],[[13,15],8],[[13,15],8],[[]],[[]],[[13,15]],[[13,16],17],[[13,15],[[18,[17]]]],[[],5],[[],5],[[],5],[[],5],[[],6],[[],6],[[13,15],[[5,[[7,[12]],9]]]],0,0,0,0,0,0,[[]],[[]],[19,19],[[]],[[19,19],10],[[19,2],3],[[19,2],3],[[]],0,[19,[[18,[20]]]],[[]],[[[22,[21]]],[[7,[19]]]],[[[22,[21]]],19],[19,[[18,[23]]]],[[],19],[[]],[[],4],[[],5],[[],5],[[],[[7,[19]]]],[[],6],0,0,0,[15,[[18,[20]]]],[15,[[18,[23]]]],0,0,0,0,[[]],[[]],[[]],[[]],[12,12],[[]],[[12,12],10],[[],10],[[12,2],3],[[24,2],3],[[]],[[]],[[]],[[]],[25,[[5,[12,24]]]],[25,12],[[]],[[],5],[[],5],[[],5],[[],5],[[],6],[[],6],0,0,0,0,0,0,[[]],[[]],[[]],[[]],[[]],[[]],0,[16,16],[26,26],[[]],[[]],[[16,16],10],[[26,26],10],[[17,2],3],[[16,2],3],[[26,2],3],[[]],[[]],[[]],[16,[[18,[15]]]],0,0,[[]],[[]],[[]],0,[[26,23],16],[[]],[[]],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],6],[[],6],[[],6],[[17,20],[[5,[[7,[12]],9]]]],0,0,0],"c":[],"p":[[3,"Board",3],[3,"Formatter",220],[6,"Result",220],[3,"String",221],[4,"Result",222],[3,"TypeId",223],[4,"Option",224],[3,"Cell",38],[4,"CandidateError",38],[15,"bool"],[15,"u16"],[3,"Num",145],[3,"Grid",84],[4,"GridError",84],[6,"GridIdx",113],[3,"SectionInfo",172],[3,"Section",172],[15,"array"],[3,"Idx",113],[6,"InnerIdx",113],[15,"usize"],[8,"Into",225],[6,"SectionIdx",113],[4,"NumErr",145],[15,"u8"],[4,"SectionKind",172],[8,"Solver",15],[8,"LoggingSolver",15],[8,"StepSolver",15],[8,"StepLoggingSolver",15],[8,"IntoIdx",113],[8,"TryIntoIdx",113]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
